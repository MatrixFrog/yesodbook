<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="real-life-examples-http-enumerator-package"><title id="x-1">Real life examples: http-enumerator package</title><conbody id="x-2"><p id="reallife1">I started working on these tutorials as I was working on the <apiname id="x1">http-enumerator</apiname> package. I think the usage of enumeratees there is a great explanation of the benefits they can offer in real life. There are three different ways the response body can be broken up:</p><ul id="x2"><li id="x3">Chunked encoding. In this case, the web server gives a hex string specifying the length of the next chunk and then that chunk. At the end, it sends a 0 to indicate the end of that response.</li><li id="x4">Content length. Here, the web server sends a header before any of the body is sent specifying the total length of the body.</li><li id="x5">Nothing at all. In this case, the response body lasts until an end-of-file.</li></ul><p id="reallife2">In addition, the body may or may not be GZIP compressed. We end up with the following enumeratees, each with type signature <codeph id="x6">Enumeratee ByteString ByteString m b</codeph>: chunkedEncoding, contentLength and ungzip. We then get to do something akin to:</p><codeblock outputclass="haskell" id="x7">let parseBody x =
        if ("transfer-encoding", "chunked") `elem` responseHeaders
            then joinI $ chunkedEncoding $$ x
            else case mlen of
                    Just len -&gt; joinI $ contentLength len $$ x
                    Nothing -&gt; x -- no enumeratee applied at all
let decompress x =
        if ("content-encoding", "gzip") `elem` responseHeaders
            then joinI $ ungzip $$ x
            else x
run_ $ socketEnumerator $$ parseBody $ decompress $ bodyIteratee</codeblock><p id="reallife3">We create a chain: the data from the server is fed into the parseBody function. In the case of chunked encoding, the data is processed appropriately and then headers are filtered out. If we are dealing with content length, then only the specified number of bytes are read. And in the case of neither of those, parseBody is a no-op.</p><p id="reallife4">Whatever the case may be, the raw response body is then fed into decompress. If the body is GZIPed, then ungzip inflates it, otherwise decompress is a no-op. Finally, the parsed and inflated data is fed into the user-supplied bodyIteratee function. The user remains blissfully unaware of any steps the data took to get to him/her.</p></conbody></concept>