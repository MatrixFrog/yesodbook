<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="even-more-general"><title>Even more general</title><conbody><p id="moregen1">Of course, it would be nice if we could apply this transformation to *any* iteratee. To start with, let's just pass the inner iteratee and the mapping function as parameters.</p><codeblock outputclass="haskell" id="x1">mapIter :: Monad m =&gt; (aOut -&gt; aIn) -&gt; Iteratee aIn m b -&gt; Iteratee aOut m b
mapIter f innerIter = Iteratee $ do
    innerStep &lt;- runIteratee innerIter
    return $ go innerStep
  where
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -&gt; Iteratee $ do
        let ints = fmap f strings
        step &lt;- runIteratee $ k ints
        return $ go step</codeblock><p id="moregen2">We could call this like:</p><codeblock outputclass="haskell" id="x2">run_ (lineEnum $$ mapIter read sumIter) &gt;&gt;= print</codeblock><p id="moregen3">Nothing much to see here, it's basically identical to the previous version. What's funny is that enumerator comes built in with a <codeph id="x3">map</codeph> function to do just this, but it has a significantly different type signature:</p><codeblock outputclass="haskell" id="x4">map :: Monad m =&gt; (ao -&gt; ai) -&gt; Enumeratee ao ai m b</codeblock><p id="moregen4">since:</p><codeblock outputclass="haskell" id="x5">type Enumeratee aOut aIn m b = Step aIn m b -&gt; Iteratee aOut m (Step aIn m b)</codeblock><p id="moregen5">that's equivalent to:</p><codeblock outputclass="haskell" id="x6">map :: Monad m =&gt; (aOut -&gt; aIn) -&gt; Step aIn m b -&gt; Iteratee aOut m (Step aIn m b)</codeblock><p id="moregen6">What's with all this extra complication in type signature? Well, it's not necessary for map itself, but it <i id="x7">is</i> necessary for a whole bunch of other similar functions. But let's focus on this map for a second so we don't get lost: the first argument is the same old mapping function we had before. The second argument is a Step value. This isn't really so surprising: in our mapIter, we took an Iteratee with the same parameters, and we internally just unwrapped it to a Step.</p><p id="moregen7">But what's happening with that return value? Remembering the meanings for all these datatypes, it's an Iteratee which will be fed a stream of <codeph id="x8">aOut</codeph>s and return a Step (aka, a new iteratee, right?). This kind of makes intuitive sense: we've introduced a middle man which accepts input from one source and transforms a Step to a newer state.</p><p id="moregen8">But now perhaps the trickiest part of the whole thing: how do we actually <i id="x9">use</i> this map function? It turns out that an Enumeratee is close enough in type signature to an Enumerator that we can just do:</p><codeblock outputclass="haskell" id="x10">map read $$ sumIter</codeblock><p id="moregen9">But the type signature on <i id="x11">that</i> turns out to be a little bit weird:</p><codeblock outputclass="haskell" id="x12">Iteratee String m (Step Int m Int)</codeblock><p id="moregen10">Remembering that an Iteratee is just a wrapped up Step, what we've got <i id="x13">here</i> is an iteratee that takes Strings and returns an Iteratee, which in turn takes Ints and produces an Int. Having this fancy result allows us to do one of our great tricks with iteratees: plug in data from multiple sources. For example, we could plug some Strings into this whole ugly thing, run it, get a <i id="x14">new</i> iteratee which takes Ints, feed <i id="x15">that</i> some Ints and get an Int result.</p><p id="moregen11">(If all that went over your head, don't worry. I won't be talking about that kind of stuff any more.)</p><p id="moregen12">But often times, we <i id="x16">don't</i> need all of that power. We just want to stick our enumeratee onto our iteratee and get a new iteratee. In our case, we want to attach our map onto the sumIter to produce a new iteratee that takes Strings and returns Ints. In order to do that, we need a function like this:</p><codeblock outputclass="haskell" id="x17">unnest :: Monad m =&gt; Iteratee String m (Step Int m Int) -&gt; Iteratee String m Int
unnest outer = do -- using the Monad instance of Iteratee
    inner &lt;- outer -- inner :: Step Int m Int
    go inner
  where
    go (Error e) = throwError e
    go (Yield x _) = yield x EOF
    go (Continue k) = k EOF &gt;&gt;== go</codeblock><p id="moregen13">We can then run our unholy mess with:</p><codeblock outputclass="haskell" id="x18">run_ (lineEnum $$ unnest $ map read $$ sumIter) &gt;&gt;= print</codeblock><p id="moregen14">And actually, the unnest function is available in Data.Enumerator, and it's called joinI. So we should really write:</p><codeblock outputclass="haskell" id="x19">run_ (lineEnum $$ joinI $ map read $$ sumIter) &gt;&gt;= print</codeblock></conbody></concept>