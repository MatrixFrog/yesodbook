<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="the-step-datatype"><title id="x-1">The Step datatype</title><conbody id="x-2"><p id="step1">So we need a new datatype that will represent the state of our summing operation. We're going to allow our operations to be in one of three states:</p><ul id="x1"><li id="x2">Waiting for more data.</li><li id="x3">Already calculated a result.</li><li id="x4">For convenience, we also have an error state. This isn't strictly necessary (it could be modeled by choosing an EitherT kind of monad, for example), but it's simpler.</li></ul><p id="step2">As you could guess, these states will correspond to three constructors for the Step datatype. The error state is modeled by <codeph id="x5">Error SomeException</codeph>, building on top of Haskell's extensible exception system. The already calculated constructor is:</p><codeblock outputclass="haskell" id="x6">Yield b (Stream a)</codeblock><p id="step3">Here, a is the <i id="x7">input</i> to our iteratee and b is the <i id="x8">output</i>. This constructor allows us to simultaneously produce a result and save any "leftover" input for another iteratee that may run after us. (This won't be the case with the sum function, which always consumes all its input, but we'll see some other examples that do not consume all output.)</p><p id="step4">Now the question is how to represent the state of an iteratee that's waiting for more data. You might at first want to declare some datatype to represent the internal state and pass that around somehow. That's not how it works: instead, we simply use a function (very Haskell of us, right?):</p><codeblock outputclass="haskell" id="x9">Continue (Stream a -&gt; Iteratee a m b)</codeblock><p id="step5">Eureka! We've finally seen the Iteratee datatype! Actually, Iteratee is a very boring datatype that is only present to allow us to declare cool instances (eg, Monad) for our functions. Iteratee is defined as:</p><codeblock outputclass="haskell" id="x10">newtype Iteratee a m b = Iteratee (m (Step a m b))</codeblock><p id="step5a">And the complete Step datatype is:</p><codeblock outputclass="haskell" id="x11">data Step a m b = Error SomeException 
                | Yield b (Stream a) 
                | Continue (Stream a -&gt; Iteratee a m b)</codeblock><p id="step6">This is important: <b id="x12">Iteratee is just a newtype wrapper around a Step inside a monad</b>. Just keep that in mind as you look at definitions in the enumerator package. So knowing this, we can think of the Continue constructor as:</p><codeblock outputclass="haskell" id="x13">Continue (Stream a -&gt; m (Step a m b))</codeblock><p id="step7">That's much easier to approach: that function takes some input data and returns a new state of the iteratee. Let's see what our sum function would look like using this Step datatype:</p><codeblock outputclass="haskell" id="x14">sum5 :: Monad m =&gt; Step Int m Int -- Int input, any monad, Int output
sum5 =
    Continue $ go 0 -- a common pattern, you always start with a Continue
  where
    go :: Monad m =&gt; Int -&gt; Stream Int -&gt; Iteratee Int m Int
    -- Add the new input to the running sum and create a new Continue
    go runningSum (Chunks nums) = do
        let runningSum' = runningSum + sum nums
        -- This next line is *ugly*, good thing there are some helper
        -- functions to clean it up. More on that below.
        Iteratee $ return $ Continue $ go runningSum'
    -- Produce the final result
    go runningSum EOF = Iteratee $ return $ Yield runningSum EOF</codeblock>
<note id="x15">In order to run this code, you can use <codeph id="x16">run_ $ enumList 8 [1..10] sum5</codeph>. But this gets into some of the Enumerator black magic we won't discuss till later.</note>
<p id="step8">The first real line (<codeph id="x17">Continue $ go 0</codeph>) initializes our iteratee to its starting state. Just like every other sum function, we need to explicitly state that we are starting from 0 somewhere. The real workhorse is the go function. Notice how we are really passing the state of the iteratee around as the first argument to go: this is also a very common pattern in iteratees.</p><p id="step9">We need to handle two different cases: when handed an EOF, the go function <b id="x18">must</b> Yield a value. (Well, it could also produce an Error value, but it definitely <b id="x19">cannot</b> Continue.) In that case, we simply yield the running sum and say there was no data left over. When we receive some input data via Chunks, we simply add it to the running sum and create a new Continue based on the same go function.</p><p id="step10">Now let's work on making that function a little bit prettier by using some built-in helper functions. The pattern <codeph id="x20">Iteratee . return</codeph> is common enough to warrant a helper function, namely:</p><codeblock outputclass="haskell" id="x21">returnI :: Monad m =&gt; Step a m b -&gt; Iteratee a m b
returnI = Iteratee . return</codeblock><p id="step11">So for example,</p><codeblock outputclass="haskell" id="x22">go runningSum EOF = Iteratee $ return $ Yield runningSum EOF</codeblock><p id="step12">becomes</p><codeblock outputclass="haskell" id="x23">go runningSum EOF = returnI $ Yield runningSum EOF</codeblock><p id="step13">But even <i id="x24">that</i> is common enough to warrant a helper function:</p><codeblock outputclass="haskell" id="x25">yield :: Monad m =&gt; b -&gt; Stream a -&gt; Iteratee a m b
yield x chunk = returnI $ Yield x chunk</codeblock><p id="step14">so our line becomes</p><codeblock outputclass="haskell" id="x26">go runningSum EOF = yield runningSum EOF</codeblock><p id="step15">Similarly,</p><codeblock outputclass="haskell" id="x27">Iteratee $ return $ Continue $ go runningSum'</codeblock><p id="step16">becomes</p><codeblock outputclass="haskell" id="x28">continue $ go runningSum'</codeblock></conbody></concept>