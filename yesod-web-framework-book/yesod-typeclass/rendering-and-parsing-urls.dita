<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="rendering-and-parsing-urls"><title id="x-1">Rendering and Parsing URLs</title><conbody id="x-2"><p id="rpu1">We've already mentioned how Yesod is able to automatically render type-safe URLs into a textual URL that can be inserted into an HTML page. Let's say we have a route definition that looks like:</p><codeblock outputclass="haskell" id="x1">mkYesod "MyApp" [parseRoutes|
/some/path SomePathR GET
]</codeblock><p id="rpu2">If we place SomePathR into a hamlet template, how does Yesod render it? Yesod always tries to construct <i id="x2">absolute</i> URLs. This is especially useful once we start creating XML sitemaps and Atom feeds, or sending emails. But in order to construct an absolute URL, we need to know the domain name of the application.</p><p id="rpu3">You might think to just get that information from the user's request, but we still need to deal with ports. And even if we get the port number from the request, are we using HTTP or HTTPS? And even if you know <i id="x3">that</i>, such an approach would break one of our RESTful principles: depending on how the user submitted a request would generate different URLs. For example, we would generate different URLs depending if the user connected to "example.com" or "www.example.com".</p><p id="rpu4">And finally, Yesod doesn't make any assumption about <i id="x4">where</i> you host your application. For example, I may have a mostly static site (http://static.example.com/), but I'd like to stick a Yesod-powered Wiki at /wiki/. There is no reliable way for an application to determine what subpath it is being hosted from. So instead of doing all of this guesswork, Yesod needs you to tell it the <term id="x5">application root</term>.</p><p id="rpu5">So using the wiki example, you would write your Yesod instance as:</p><codeblock outputclass="haskell" id="x6">instance Yesod MyWiki where approot _ = "http://static.example.com/wiki"</codeblock><p id="rpu6">Notice that there is no trailing slash there. Next, when Yesod wants to construct a URL for SomePathR, it determines that the relative path for SomePathR is "/some/path", appends that to your approot and creates "http://static.example.com/wiki/some/path".</p><p id="rpu7">This also explains our cryptic <codeph id="x7">approot _ = ""</codeph>: for our examples in the book, we're always serving from the root of the domain (in our case, localhost). By using an empty string, SomePathR renders to "/some/path", which works just fine. In real life applications, however, you should use a real application root.</p>
<note id="x13">The first argument to approot is the site foundation. This means that you could load your approot at program initialization, store it in the foundation, and then retrieve it. This is in fact what the scaffolded site does, using a YAML config file.</note>
<p id="rpu8">And by the way, the site template generated by the scaffolding tool automatically uses conditional compilation to switch between development and production builds, so you can easily test on one domain- like localhost- and serve from a different domain.</p><note id="x8" type="other" othertype="advanced"><p id="rpu9">You might be wondering: why does approot take that first argument if it is always ignored? There are two reasons:</p><ul id="x9"><li id="x10">It is needed by Haskell's type system to determine which instance of Yesod to use for grabbing the typeclass.</li><li id="x11">And actually, the first argument is <i id="x12">not</i> always ignored. For example, if you want to load the application root value from a configuration file, the most logical place to store that value is in the foundation datatype, and then for the approot function to grab the value from there.</li></ul></note></conbody></concept>