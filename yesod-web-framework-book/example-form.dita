<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="example-form"><title id="x-1">Example: Form</title><conbody id="x-2"><codeblock id="x1" outputclass="lhaskell">&lt;p&gt;Forms can be a tedious part of web development since they require synchronization of code in many different areas: the HTML form declaration, parsing of the form and reconstructing a datatype from the raw values. The Yesod form library simplifies things greatly. We'll start off with a basic application.&lt;/p&gt;


&gt; {-# LANGUAGE TypeFamilies, QuasiQuotes, OverloadedStrings, MultiParamTypeClasses, TemplateHaskell #-}
&gt; import Yesod
&gt; import Control.Applicative
&gt; import Data.Text (Text)

&gt; data FormExample = FormExample
&gt; type Handler = GHandler FormExample FormExample
&gt; mkYesod "FormExample" [parseRoutes|
&gt; / RootR GET
&gt; |]
&gt; instance Yesod FormExample where approot _ = ""

Next, we'll declare a Person datatype with a name and age. After that, we'll create a formlet. A formlet is a declarative approach to forms. It takes a Maybe value and constructs either a blank form, a form based on the original value, or a form based on the values submitted by the user. It also attempts to construct a datatype, failing on validation errors.

&gt; data Person = Person { name :: Text, age :: Int }
&gt;     deriving Show
&gt; personFormlet p = fieldsToTable $ Person
&gt;     &lt;$&gt; stringField "Name" (fmap name p)
&gt;     &lt;*&gt; intField "Age" (fmap age p)

We use an applicative approach and stay mostly declarative. The "fmap name p" bit is just a way to get the name from within a value of type "Maybe Person".

&gt; getRootR :: Handler RepHtml
&gt; getRootR = do
&gt;     (res, wform, enctype) &lt;- runFormGet $ personFormlet Nothing

&lt;p&gt;We use runFormGet to bind to GET (query-string) parameters; we could also use runFormPost. The "Nothing" is the initial value of the form. You could also supply a "Just Person" value if you like. There is a three-tuple returned, containing the parsed value, the HTML form as a widget and the encoding type for the form.&lt;/p&gt;

&lt;p&gt;We use a widget for the form since it allows embedding CSS and Javascript code in forms directly. This allows unobtrusive adding of rich Javascript controls like date pickers.&lt;/p&gt;

&gt;     defaultLayout $ do
&gt;         setTitle "Form Example"
&gt;         form &lt;- extractBody wform

&lt;p&gt;extractBody returns the HTML of a widget and "passes" all of the other declarations (the CSS, Javascript, etc) up to the parent widget. The rest of this is just standard Hamlet code and our main function.&lt;/p&gt;

&gt;         addHamlet [hamlet|
&gt; &lt;p&gt;Last result: #{show res}
&gt; &lt;form enctype="#{enctype}"&gt;
&gt;     &lt;table&gt;
&gt;         \^{form}
&gt;         &lt;tr&gt;
&gt;             &lt;td colspan="2"&gt;
&gt;                 &lt;input type="submit"&gt;
&gt; |]
&gt; 
&gt; main = warpDebug 3000 FormExample
</codeblock></conbody></concept>