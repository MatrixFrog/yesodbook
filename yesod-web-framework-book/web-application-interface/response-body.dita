<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="response-body"><title>Response Body</title><conbody><p id="resbod1">Haskell has a datatype known as a lazy bytestring. By utilizing laziness, you can create large values without exhausting memory. Using lazy I/O, you can do such tricks as having a value which represents the entire contents of a file, yet only occupies a small memory footprint. In theory, a lazy bytestring is the only representation necessary for a response body.</p><p id="resbod2">In practice, while lazy byte strings are wonderful for generating "pure" values, the lazy I/O necessary to read a file introduces some non-determinism into our programs. When serving thousands of small files a second, the limiting factor is not memory, but file handles. Using lazy I/O, file handles may not be freed immediately, leading to resource exhaustion. To deal with this, WAI uses <term id="x1">enumerators</term>.</p><p id="resbod3">Enumerators are really a simple concept with a lot of complications surrounding them. Most basically, an enumerator is a <i id="x2">data producer</i>, that hands chunks of data one at a time to an <term id="x3">iteratee</term>, which is a <i id="x4">data consumer</i>. In the case of WAI, the request body would be an enumerator which would produce data by reading it from a file. The iteratee would be the server, which would send these chunks of data to the client.</p><p id="resbod4">There are two further optimizations: many systems provide a sendfile system call, which sends a file directly to a socket, bypassing a lot of the memory copying inherent in more general I/O system calls. Additionally, there is a datatype in Haskell called <codeph id="x5">Builder</codeph> which allows efficient copying of bytes into buffers.</p><p id="resbod5">The WAI response body therefore has three constructors: one for pure builders (<codeph id="x6">ResponseBuilder</codeph>), one for enumerators of builders (<codeph id="x7">ResponseEnum</codeph>) and one for files (<codeph id="x8">ResponseFile</codeph>).</p></conbody></concept>