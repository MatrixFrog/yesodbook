<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="type-safe-runtime-hamlet"><title>Type-safe runtime Hamlet</title><body><foreign outputclass="html">&lt;h3&gt;Current Hamlet inclusion options&lt;/h3&gt;
&lt;p&gt;I recently released &lt;a href="http://hackage.haskell.org/package/hamlet-0.4.2"&gt;Hamlet version 0.4.2&lt;/a&gt;, which added an often-requested feature: runtime Hamlet templates. This allows some really cool possibilities, such as using Hamlet templates in &lt;a href="http://hackage.haskell.org/package/hakyll"&gt;Hakyll&lt;/a&gt;. There are now three different ways to include a Hamlet template in your code; let's look at the options and their relatives strengths and weaknesses.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quasi-quoted&lt;ul&gt;
        &lt;li&gt;Advantages&lt;ul&gt;
            &lt;li&gt;Fully type-checked at compile time.&lt;/li&gt;
            &lt;li&gt;Changing the template automatically forces a recompile.&lt;/li&gt;
            &lt;li&gt;Does as much work as possible at compile-time; faster runtime execution.&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
        &lt;li&gt;Disadvantages&lt;ul&gt;
            &lt;li&gt;Some people like to keep their templates and code separate.&lt;/li&gt;
            &lt;li&gt;The only way to see the result of a template change is a recompile- slows down development cycle.&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Template Haskell external file&lt;ul&gt;
        &lt;li&gt;Advantages&lt;ul&gt;
            &lt;li&gt;Fully type-checked at compile time.&lt;/li&gt;
            &lt;li&gt;Does as much work as possible at compile-time; faster runtime execution.&lt;/li&gt;
            &lt;li&gt;Keeps templates and code separate.&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
        &lt;li&gt;Disadvantages&lt;ul&gt;
            &lt;li&gt;Changing the template &lt;b&gt;does not&lt;/b&gt; automatically forces a recompile; you might see stale content if you're not careful.&lt;/li&gt;
            &lt;li&gt;The only way to see the result of a template change is a recompile- slows down development cycle.&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Runtime templates&lt;ul&gt;
        &lt;li&gt;Advantages&lt;ul&gt;
            &lt;li&gt;Immediately see results of template changes, without a recompile.&lt;/li&gt;
            &lt;li&gt;Keeps templates and code separate.&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
        &lt;li&gt;Disadvantages&lt;ul&gt;
            &lt;li&gt;Not type-checked at all.&lt;/li&gt;
            &lt;li&gt;Parse errors only appear at runtime.&lt;/li&gt;
        &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, it's very difficult to get runtime templates to interact well with the first two options. In the case of Yesod, there is basically no machinery in place to help you out; you'll have to write it all yourself.&lt;/p&gt;
&lt;h3&gt;The Fourth Option&lt;/h3&gt;
&lt;p&gt;However, Hamlet 0.5 is going to include a fourth method which will have the following characteristics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Advantages&lt;ul&gt;
    &lt;li&gt;Fully type-checked at compile time.&lt;/li&gt;
    &lt;li&gt;Is code-wise identical to the external Template Haskell method.&lt;/li&gt;
    &lt;li&gt;You can view changes to your template without a recompile. If you have made changes the break the type-safety of your template, you will get an error message and be informed you must recompile.&lt;/li&gt;
    &lt;li&gt;You can use this method during testing and easily switch all of your code to the external TH version for production, thereby &lt;b&gt;avoiding all runtime costs&lt;/b&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disadvantages&lt;ul&gt;
    &lt;li&gt;Since you are avoiding a compilation step, sometimes you'll need to manually initiate a recompile.&lt;/li&gt;
    &lt;li&gt;Some of the more advanced Hamlet tricks available to quasi-quoted and TH templates are not available. This shouldn't affect most people.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Half runtime, half Template Haskell, and a little unsafe&lt;/h3&gt;
&lt;p&gt;Let's say that I have the simple Hamlet template &lt;code&gt;Hello $name$&lt;/code&gt;. If we use either quasi-quoted or TH Hamlet, &lt;code&gt;name&lt;/code&gt; will be converted into an &lt;code&gt;Exp&lt;/code&gt; and will reference the variable in scope called &lt;code&gt;name&lt;/code&gt;. If we use runtime Hamlet, we would need an appropriate &lt;code&gt;HamletData&lt;/code&gt; value, something looking like &lt;code&gt;HDMap [("name", HDHtml $ string name)]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now let's say that we want to change that template to &lt;code&gt;Hello $name$!&lt;/code&gt;. All I've done is added an exclamation point, so I &lt;b&gt;know&lt;/b&gt; the type safety of the template has not been affected. Here are the results for the three inclusion options.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Quasi-quoted&lt;/dt&gt;
&lt;dd&gt;Fully recompile the entire module containing the template.&lt;/dd&gt;
&lt;dt&gt;Template Haskell&lt;/dt&gt;
&lt;dd&gt;The change won't appear until you &lt;i&gt;manually&lt;/i&gt; force the module to be recompiled.&lt;/dd&gt;
&lt;dt&gt;Runtime&lt;/dt&gt;
&lt;dd&gt;Change appears immediately without a recompile.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;However, let's say that I change the template now to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%ul
    $forall names name
        %li Hello $name$&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I also immediately fix up my Haskell code so that instead of &lt;code&gt;name = "Michael"&lt;/code&gt; I have &lt;code&gt;names = words "Michael Miriam Eliezer Gavriella"&lt;/code&gt;. Now, the results are:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Quasi-quoted&lt;/dt&gt;
&lt;dd&gt;Fully recompile the entire module containing the template.&lt;/dd&gt;
&lt;dt&gt;Template Haskell&lt;/dt&gt;
&lt;dd&gt;Fully recompile the entire module containing the template.&lt;/dd&gt;
&lt;dt&gt;Runtime&lt;/dt&gt;
&lt;dd&gt;Code won't compile until you &lt;i&gt;also&lt;/i&gt; modify the HamletData value to something like &lt;code&gt;HDMap [("names", HDList $ map (HDHtml . string) names)]&lt;/code&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;So with options 1 and 2, we get an unnecessary recompile step in case 1. In case 2, we require Haskell code changes, so the recompile is unavoidable. However, it's much more tedious to make the code changes for option 3.  Also, let's say that we made the Haskell code change (name to names) &lt;i&gt;before&lt;/i&gt; the template changes. Options 1 and 2 would give us a compile-time error message, while option 3 would only complain at runtime.&lt;/p&gt;
&lt;p&gt;What we really want is to have that &lt;b&gt;HamletData value constructed for us&lt;/b&gt; by Hamlet, by reading the template file &lt;b&gt;at compile time&lt;/b&gt;. However, we also want it to &lt;b&gt;read the template file at runtime&lt;/b&gt; and apply the HamletData value to it. This is exactly what option 4 does.&lt;/p&gt;
&lt;h3&gt;How it works&lt;/h3&gt;
&lt;p&gt;There's a new function in Hamlet 0.5: hamletFileDebug. (Don't get attached to any names, I expect a lot of renamings before it's released.) It has an identical signature to hamletFile (the external Template Haskell version): &lt;code&gt;FilePath -&amp;gt; Q Exp&lt;/code&gt;. hamletFile pulls in the template from the given file at compile time, parses it and converts it into Haskell code that gets compiled. Template Haskell changes the &lt;code&gt;Q Exp&lt;/code&gt; into a value &lt;code&gt;Hamlet url&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;hamletFileDebug is slightly different. It also pulls in the template from the file at compile time and parses it. Next, it scans through the parsed template and finds all references to variables and how they are used. Using the example above, it would notice that the template refers to &lt;code&gt;name&lt;/code&gt; and expects it to be a String. It then creates the appropriate &lt;code&gt;HamletData&lt;/code&gt; value based on all these references.&lt;/p&gt;
&lt;p&gt;Like hamletFile, hamletFileDebug will also return a value of type &lt;code&gt;Hamlet url&lt;/code&gt;. However, this value will in fact read the specified file &lt;b&gt;at runtime&lt;/b&gt; and render it against the &lt;code&gt;HamletData&lt;/code&gt; value each time. In order to achieve this, it has to use &lt;code&gt;unsafePerformIO&lt;/code&gt;; since this is intended to enhance your development, and should not be used in production, I think it's a fair use.&lt;/p&gt;
&lt;h3&gt;How it plays out&lt;/h3&gt;
&lt;p&gt;So how does this interact with a normal Hamlet development workflow? Let's go back to the name to names example: if you change your Haskell code first, hamletFileDebug will get called again during your recompile and will inspect the template. It will notice that the &lt;code&gt;name&lt;/code&gt; variable is no longer in scope, and you will get a compile-time error.&lt;/p&gt;
&lt;p&gt;On the other hand, if you change the Hamlet template file first, you'll end up with a runtime error. However, I think it's a fair trade-off: you're skipping a compile cycle here, so the &lt;i&gt;only&lt;/i&gt; way to get an error message is at runtime.&lt;/p&gt;
&lt;p&gt;Looking at the exclamation mark example, no code changes are required, only template changes. In this case, your changes will become immediately visible.&lt;/p&gt;
&lt;h3&gt;Next steps&lt;/h3&gt;
&lt;p&gt;I'm very excited about how this change will affect my development cycle; it will make it much easier to play around with HTML changes to see the results. This also converges with some other work I've been doing: Stylish. I created &lt;a href="http://github.com/snoyberg/stylish"&gt;a github repo for Stylish&lt;/a&gt; a few days ago, which is meant to be Hamlet for CSS. It is based on the recently released blaze-builder, which will also be the core of blaze-html 0.2.&lt;/p&gt;
&lt;p&gt;Even though Yesod offers an &lt;code&gt;addStyle&lt;/code&gt; function for including CSS declarations, I almost always use static CSS files for this purpose, simply because I can't afford to go through a whole compile cycle to test out changing the border from 2px to 3px. (I know about firebug, don't worry.) However, Hamlet 0.5 should hopefully solve this problem: by using the same technique of hamletFileDebug, I'll be able to test out style changes immediately.&lt;/p&gt;
&lt;p&gt;So now I'm announcing the inclusion of two more pieces in Hamlet 0.5: Camlet and Jamlet. They are to CSS and Javascript, respectively, what Hamlet is to HTML. Camlet is going to be what Stylish is right now: white-space sensitive CSS allowing you to embed variables from Haskell and nest CSS declarations. I think Jamlet will simply be a text pass-through for the moment, but may eventually support Javascript compression.&lt;/p&gt;
&lt;p&gt;By using these two libraries with Hamlet, you won't need to worry about deploying your static files separately. And here's the really cool feature I'm hoping to add to Yesod 0.5: caching. When you use addStyle in Yesod, it will concatenate all of the CSS declarations for a page together. It will then take a hash of that value, cache the value based on the hash, and send a &lt;code&gt;link&lt;/code&gt; tag referencing that content via the hash. When that content is served, it will have an expiration date set long in the future; since the hash value will automatically change whenever you change the CSS, you won't need to worry about users getting stale CSS files. The same will be true for Javascript.&lt;/p&gt;
&lt;p&gt;This will also give you a number of minor benefits. For example, instead of hard-coding CSS names in your HTML, CSS and JavaScript separately, you could declare the name once in Haskell and reference that variable throughout. You'll be alerted &lt;b&gt;at compile time&lt;/b&gt; if you've made a typo in a CSS class name. You're also guaranteed to have well-formed CSS files.&lt;/p&gt;
&lt;p&gt;I'm very excited about all of these changes, and hope to be making these releases soon. Let me know your thoughts on this earlier, rather than later, if possible. Along with the database migration additions, I think Yesod 0.5 is going to be a very fun release.&lt;/p&gt;
</foreign></body></topic>