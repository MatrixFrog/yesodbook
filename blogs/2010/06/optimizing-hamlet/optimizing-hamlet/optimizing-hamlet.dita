<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="optimizing-hamlet"><title>Optimizing Hamlet</title><body><foreign outputclass="html">&lt;h3 style="margin-top:2em"&gt;Overview&lt;/h3&gt;
&lt;p&gt;You can find &lt;a href="http://old.nabble.com/Google-Summer-of-Code:-BlazeHTML-RFC-to28690433.html"&gt;the original benchmarks by Jeremy Shaw&lt;/a&gt; for Blaze and Hsp. The Hamlet-3 benchmark is now &lt;a href="http://github.com/snoyberg/hamlet/blob/master/bigtable.hs"&gt;part of the Hamlet repository&lt;/a&gt;. The final results are as follows:&lt;/p&gt;
&lt;a href="http://www.chartgo.com/linkshare.do?id=86813994aa"&gt;&lt;img src="http://www.chartgo.com/link.do?id=86813994aa" alt="Haskell Templating Systems BigTable Benchmark" border="0"&gt;&lt;/a&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;It seems like the new cool thing in the Haskell web ecosystem is benchmarking: we all want to use the fastest libraries out there. Personally, I'm much more interested in type-safe, concise code than having the fastest library... but sometimes it's fun to optimize things.&lt;/p&gt;
&lt;p&gt;When I ran the last set of bigtable benchmarks, I was trying to determine the best backends for serving Yesod applications. However, I stumbled upon some strange performance results: namely, the text package was slower than either bytestrings or plain Strings by a significant margin. Given that Hamlet is based on the text package, this worried me a little bit. After some profiling, I noticed that there was also significant overhead from the enumerator interface.&lt;/p&gt;
&lt;p&gt;So when Jeremy Shaw posted some Criterion-based benchmarking code for Blaze and HSP, I was curious to see how Hamlet stacked up. The first set of results (based on Hamlet 0.2.3.1) were encouraging: Blaze took 105ms while Hamlet took 121ms. Hsp meanwhile pulled in at 140ms. So I was already in the ballpark of Blaze, and beating Hsp.&lt;/p&gt;
&lt;p&gt;However, I wasn't very happy with this result: Hamlet does most of its work at compile time. It's able to concatenate adjacent pieces of static text into a single string. So I began working on Hamlet 0.3, and in particular 2 optimizations.&lt;/p&gt;
&lt;h3&gt;Replace text with UTF-8 bytestrings&lt;/h3&gt;
&lt;p&gt;How many of you still write web applications with a non-UTF8 encoding? Not many I suppose. The text package, however, uses UTF-16 internally. Thus, there's a lot of extra encoding going on when using the text package as the backend.&lt;/p&gt;
&lt;p&gt;Swapping in bytestrings allowed me to completely avoid runtime-encoding of static text, and ensure that dynamic text is encoded only once. We now have 3 basic functions for creating Hamlet values:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;output :: ByteString -&amp;gt; Hamlet ...
outputOctets :: String -&amp;gt; Hamlet ...
outputString :: String -&amp;gt; Hamlet ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I put an ellipsis at the end there because the type of Hamlet is going to change throughout this post. The important thing here is the difference between outputOctets and outputString: the former converts the String to a ByteString via Data.ByteString.Char8.pack. In other words, &lt;i&gt;it performs no UTF-8 encoding&lt;/i&gt;. The Hamlet quasi-quoter UTF-8 encodes all compile-time strings and then generates code which calls outputOctets. outputString, on the other hand, &lt;i&gt;does&lt;/i&gt; perform UTF-8 encoding, and is used for runtime-generated strings.&lt;/p&gt;
&lt;p&gt;This optimization showed great results: the bigtable benchmark dropped from 120ms to 70ms.&lt;/p&gt;
&lt;h3&gt;Remove monadic interleaving&lt;/h3&gt;
&lt;p&gt;Hamlet was originally designed to support monadic action interleaving. I thought this would be a great feature: you could interleave file access with template execution, pull in a database result via an enumerator, and then have an enumerator interface for generating template results.&lt;/p&gt;
&lt;p&gt;After writing a hell of a lot of Hamlet-based code, I have not used this feature once. I'm not aware of &lt;i&gt;anyone&lt;/i&gt; using this feature. My profiling also indicated that this was another source of a performance hit. So I decided to remove it entirely.&lt;/p&gt;
&lt;p&gt;The first step was to redefine the Hamlet datatype. Previously, it was a newtype wrapper around an enumerator interface. Now, it's much simpler: &lt;code&gt;newtype Hamlet url = Hamlet ((url -&gt; String) -&gt; [ByteString] -&gt; [ByteString])&lt;/code&gt;. The first argument in there is the URL render function, and then we return a bytestring-list endomorphism. This allows very efficiecient appending of Hamlets. The main typeclass instance we use is the Monoid one:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Monoid Hamlet where
    mempty = Hamlet $ const id
    mappend (Hamlet x) (Hamlet y) = Hamlet $ \r -&gt; (x r) . (y r)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The internals of the quasi-quote also became much simpler. Another advantage I had not anticipated is much friendlier error messages.&lt;/p&gt;
&lt;p&gt;Final result: bigtable runs in only 40ms. This is a 66% improvement upon Hamlet 0.2, and a 60% advantage over BlazeHtml.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;The code for Hamlet 0.3 is available on Github, but not yet released. Since it introduces breaking changes, it requires a major version jump for dependent packages, in particular Yesod. I'm planning on doing some more testing, perhaps a little more profiling, and releasing it fairly soon. The Yesod 0.3 release will most likely wait for a release of persistent, which should also come out soon. I'm in the process now of integrating forms and generics with persistent values; hopefully we can have a first release within the next two weeks.&lt;/p&gt;
</foreign></body></topic>